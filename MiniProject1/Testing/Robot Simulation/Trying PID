import numpy as np
import matplotlib.pyplot as plt
import tkinter as tk
import time

# Setup Constants
wheel_size = 0.021  # m (radius, r)
distance_between_wheels = 0.2  # m (wheelbase, s)
encoder_ticks_per_spin = 48
time_per_move = 0.05  # s
move_speed = 0.223  # m/s (max linear speed)
max_turn_speed = 1.0  # rad/s (max angular speed)
angle_wiggle_room = 0.05  # rad
distance_wiggle_room = 0.01  # m
body_length = 0.3  # m
body_width = distance_between_wheels  # m

# Initial State
x_pos, y_pos, direction = 0.0, 0.0, 0.0
left_encoder_count, right_encoder_count = 0, 0
left_extra, right_extra = 0.0, 0.0
left_speed, right_speed = 0.0, 0.0
robot_path = [(x_pos, y_pos)]
time_data, x_data, y_data, vel_data = [0.0], [0.0], [0.0], [0.0]
goal_x, goal_y = None, None
heading_to_goal = False
last_key = None
theta_prev_error = 0.0
theta_integral = 0.0  # For PID

# Control Gains
K_theta_p = 1.5  # Proportional gain for orientation
K_theta_i = 0.02  # Integral gain for orientation
K_theta_d = 0.3  # Derivative gain for orientation
K_v = 0.8  # Distance gain

# Plot Setup
plt.ion()
fig, (ax_robot, ax_vel) = plt.subplots(2, 1, figsize=(8, 8), height_ratios=[3, 1])
ax_robot.set_xlim(-0.5, 0.5)
ax_robot.set_ylim(-0.5, 0.5)
ax_robot.set_title('Robot Movement')
ax_robot.set_xlabel('X (m)')
ax_robot.set_ylabel('Y (m)')
ax_robot.grid(True)
robot_shape, = ax_robot.plot([], [], 'b-', lw=2)
left_wheel_dot, = ax_robot.plot([], [], 'ro', ms=8)
right_wheel_dot, = ax_robot.plot([], [], 'ro', ms=8)
trail, = ax_robot.plot([], [], 'g--', lw=1)
goal_spot, = ax_robot.plot([], [], 'kx', ms=10)
front_arrow, = ax_robot.plot([], [], 'b-', lw=2)
planned_route, = ax_robot.plot([], [], 'r--', lw=1)

ax_vel.set_title('Velocity vs. Time')
ax_vel.set_xlabel('Time (s)')
ax_vel.set_ylabel('Velocity (m/s)')
ax_vel.grid(True)
vel_line, = ax_vel.plot([], [], 'g-', label='Speed')
ax_vel.legend()

def figure_out_ticks(left_speed, right_speed, time_step):
    global x_pos, y_pos, direction, left_encoder_count, right_encoder_count, left_extra, right_extra, robot_path, time_data, x_data, y_data, vel_data
    left_turn = left_speed * time_step / wheel_size
    right_turn = right_speed * time_step / wheel_size
    left_extra += left_turn * encoder_ticks_per_spin / (2 * np.pi)
    right_extra += right_turn * encoder_ticks_per_spin / (2 * np.pi)
    left_ticks = int(left_extra)
    right_ticks = int(right_extra)
    left_extra -= left_ticks
    right_extra -= right_ticks
    left_encoder_count += left_ticks
    right_encoder_count += right_ticks
    forward_speed = (right_speed + left_speed) / 2
    spin_speed = (right_speed - left_speed) / distance_between_wheels
    x_pos += forward_speed * np.cos(direction) * time_step
    y_pos += forward_speed * np.sin(direction) * time_step
    direction += spin_speed * time_step
    direction = np.arctan2(np.sin(direction), np.cos(direction))
    time_data.append(time_data[-1] + time_step)
    x_data.append(x_pos)
    y_data.append(y_pos)
    vel = np.sqrt((forward_speed * np.cos(direction))**2 + (forward_speed * np.sin(direction))**2)
    vel_data.append(vel)
    robot_path.append((x_pos, y_pos))
    return left_ticks, right_ticks

def draw_robot_and_vel():
    half_long = body_length / 2
    half_wide = body_width / 2
    corners = [(-half_long, -half_wide), (half_long, -half_wide),
               (half_long, half_wide), (-half_long, half_wide), (-half_long, -half_wide)]
    rx, ry = [], []
    for cx, cy in corners:
        rx.append(x_pos + cx * np.cos(direction) - cy * np.sin(direction))
        ry.append(y_pos + cx * np.sin(direction) + cy * np.cos(direction))
    robot_shape.set_data(rx, ry)
    left_x = x_pos - (distance_between_wheels / 2) * np.sin(direction)
    left_y = y_pos + (distance_between_wheels / 2) * np.cos(direction)
    right_x = x_pos + (distance_between_wheels / 2) * np.sin(direction)
    right_y = y_pos - (distance_between_wheels / 2) * np.cos(direction)
    left_wheel_dot.set_data([left_x], [left_y])
    right_wheel_dot.set_data([right_x], [right_y])
    boner_size = half_long * 1.2
    arrow_x = [x_pos, x_pos + boner_size * np.cos(direction)]
    arrow_y = [y_pos, y_pos + boner_size * np.sin(direction)]
    front_arrow.set_data(arrow_x, arrow_y)
    px, py = zip(*robot_path)
    trail.set_data(px, py)
    if goal_x is not None and goal_y is not None:
        goal_spot.set_data([goal_x], [goal_y])
        planned_route.set_data([x_pos, goal_x], [y_pos, goal_y])
    else:
        planned_route.set_data([], [])
    all_x = px + (goal_x,) if goal_x else px
    all_y = py + (goal_y,) if goal_y else py
    ax_robot.set_xlim(min(all_x) - 0.5, max(all_x) + 0.5)
    ax_robot.set_ylim(min(all_y) - 0.5, max(all_y) + 0.5)

    ax_vel.set_xlim(0, max(time_data) + 0.1)
    ax_vel.set_ylim(-0.1, max(vel_data) + 0.1)
    vel_line.set_data(time_data, vel_data)

    plt.draw()
    plt.pause(0.001)

def tell_me_where_we_are(left_ticks, right_ticks):
    print(f"Left Encoder: {left_encoder_count} (+{left_ticks}) | "
          f"Right Encoder: {right_encoder_count} (+{right_ticks})")
    print(f"At: x = {x_pos:.3f} m, y = {y_pos:.3f} m | Facing: {direction:.3f} rad")

def catch_key_press(event):
    global last_key, heading_to_goal
    if not heading_to_goal:
        key = event.keysym.lower()
        if key in ['w', 'a', 's', 'd', 'q']:
            last_key = key

def pick_a_spot():
    global goal_x, goal_y, heading_to_goal
    try:
        goal_x = float(x_input.get())
        goal_y = float(y_input.get())
        heading_to_goal = True
        status_label.config(text=f"Aiming for: ({goal_x:.2f}, {goal_y:.2f})")
        print(f"Heading from ({x_pos:.3f}, {y_pos:.3f}) to ({goal_x:.3f}, {goal_y:.3f})")
        how_far = np.sqrt((goal_x - x_pos)**2 + (goal_y - y_pos)**2)
        which_way = np.arctan2(goal_y - y_pos, goal_x - x_pos)
        print(f"  That’s {how_far:.3f} meters away")
        print(f"  Need to face {which_way:.3f} radians")
    except ValueError:
        status_label.config(text="Oops, bad X or Y number")

def control_algorithm(target_angle, target_distance):
    global left_speed, right_speed, theta_prev_error, theta_integral
    # Observe state
    x_t, y_t, theta_t = x_pos, y_pos, direction
    x_D, y_D, theta_D = goal_x, goal_y, target_angle
    
    # Compute v_B
    dist_error = np.sqrt((x_D - x_t)**2 + (y_D - y_t)**2)
    v_B = K_v * dist_error
    v_B = np.clip(v_B, 0, move_speed)  # No min speed, allow 0
    
    # Compute theta_dot with PID control
    angle_error = target_angle - theta_t
    if abs(angle_error) > np.pi: angle_error -= 2 * np.pi * np.sign(angle_error)  # Shortest path
    theta_integral += angle_error * time_per_move
    theta_integral = np.clip(theta_integral, -1.0, 1.0)  # Prevent windup
    theta_deriv = (angle_error - theta_prev_error) / time_per_move
    theta_dot = K_theta_p * angle_error + K_theta_i * theta_integral + K_theta_d * theta_deriv
    theta_dot = np.clip(theta_dot, -max_turn_speed, max_turn_speed)
    theta_prev_error = angle_error
    
    # Compute wheel angular velocities
    r = wheel_size
    s = distance_between_wheels
    phi_dot_L = (v_B / r) - (s * theta_dot / (2 * r))
    phi_dot_R = (v_B / r) + (s * theta_dot / (2 * r))
    
    # Convert to linear speeds
    left_speed = r * phi_dot_L
    right_speed = r * phi_dot_R
    left_speed = np.clip(left_speed, -move_speed, move_speed)
    right_speed = np.clip(right_speed, -move_speed, move_speed)

def keep_moving():
    global last_key, heading_to_goal, goal_x, goal_y, left_speed, right_speed
    print("Tap WASD to slide around, or drop X,Y and hit ‘Go’ (Q to yeet outta here):")
    print("W: Zoom forward, A: Swerve left, S: Reverse it, D: Dip right")
    print("Starting fresh at x=0, y=0, facing 0, let’s gooo\n")

    update_count = 0
    redraw_every = 5

    while True:
        left_speed, right_speed = 0.0, 0.0

        if heading_to_goal and goal_x is not None and goal_y is not None:
            target_angle = np.arctan2(goal_y - y_pos, goal_x - x_pos)
            target_distance = np.sqrt((goal_x - x_pos)**2 + (goal_y - y_pos)**2)
            control_algorithm(target_angle, target_distance)
            status_label.config(text=f"Control to: ({goal_x:.2f}, {goal_y:.2f})")
            if abs(target_angle - direction) < angle_wiggle_room and abs(target_distance) < distance_wiggle_room:
                heading_to_goal = False
                goal_x, goal_y = None, None
                status_label.config(text="Made it!")
                print("Reached goal!")

        elif last_key == 'w':
            left_speed = move_speed
            right_speed = move_speed
        elif last_key == 's':
            left_speed = -move_speed
            right_speed = -move_speed
        elif last_key == 'a':
            left_speed = -move_speed * 0.5
            right_speed = move_speed
        elif last_key == 'd':
            left_speed = move_speed
            right_speed = -move_speed * 0.5
        elif last_key == 'q':
            print("PEACE OUT, FAM!")
            root.destroy()
            break

        if left_speed != 0 or right_speed != 0:
            left_ticks, right_ticks = figure_out_ticks(left_speed, right_speed, time_per_move)
            tell_me_where_we_are(left_ticks, right_ticks)

            update_count += 1
            if update_count % redraw_every == 0:
                draw_robot_and_vel()

        last_key = None
        root.update()
        time.sleep(time_per_move)

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Robot Buddy with Control Glow")
    root.geometry("300x200")
    root.bind("<KeyPress>", catch_key_press)
    tk.Label(root, text="Where to? X:").pack()
    x_input = tk.Entry(root)
    x_input.pack()
    tk.Label(root, text="Y:").pack()
    y_input = tk.Entry(root)
    y_input.pack()
    tk.Button(root, text="Go!", command=pick_a_spot).pack(pady=5)
    status_label = tk.Label(root, text="WASD or type X,Y to move")
    status_label.pack()
    try:
        keep_moving()
    except KeyboardInterrupt:
        print("\nYou yeeted me, bruh!")
    except Exception as e:
        print(f"Uh oh, shit hit the fan: {e}")
    plt.ioff()
    plt.show()
